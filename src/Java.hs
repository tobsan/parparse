{-# LANGUAGE CPP, FlexibleInstances, MultiParamTypeClasses #-}
{-# LANGUAGE UndecidableInstances, FlexibleContexts #-}

{-# OPTIONS -fno-warn-incomplete-patterns #-}
module Java where

--Genereic template
#if __GLASGOW_HASKELL__ >= 603
#include "ghcconfig.h"
#elif defined(__GLASGOW_HASKELL__)
#include "config.h"
#endif
import Data.Array
import Data.Array.Base (unsafeAt)

import Prelude hiding (foldl,foldr,null)
import Data.FingerTree -- (FingerTree,Measured,measure,split,fromList)
import qualified Data.Sequence as S 
import Data.Foldable (foldl,foldr,toList)
import Data.Monoid

-- Wrapper template
import Data.Word
import Data.Bits

lexCode ::  Measured v IntToken => String -> LexTree v 
lexCode = makeTree

tokens :: Measured v IntToken => LexTree v -> FingerTree v IntToken
tokens = undefined
-- tokens = treeToTokens

printTree = undefined

alex_base :: Array Int Int
alex_base = listArray (0,90) [-8,77,291,-109,-32,-31,419,-96,-95,-104,45,547,-85,78,292,-94,315,-91,803,739,0,852,1108,1202,1127,1383,1319,1575,1198,1661,0,1513,115,140,1917,1918,350,1221,2065,-87,2168,2104,0,2350,0,2564,141,139,79,75,-45,60,-44,-42,-72,0,-38,2319,312,-81,-48,0,0,2329,-52,11,0,0,2561,2774,-20,47,0,0,2571,2784,2817,0,0,0,0,2861,2960,3059,3158,3257,0,3334,3372,3405,3415]

alex_table :: Array Int Int
alex_table = listArray (0,3670) [0,46,46,46,46,46,55,79,80,39,3,3,9,8,12,55,55,55,50,55,52,55,50,55,46,50,34,62,62,50,58,27,55,55,50,48,55,49,57,47,69,87,87,87,87,87,87,87,87,87,55,55,56,50,53,55,67,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,54,5,55,50,67,73,83,83,83,83,84,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,55,51,55,55,2,55,55,55,73,44,0,14,14,14,14,14,14,14,14,14,14,55,5,0,0,55,0,0,14,14,14,14,14,14,0,46,46,46,46,46,5,0,0,0,5,33,5,13,90,90,90,90,90,90,90,90,90,90,46,0,14,14,14,14,14,14,29,0,0,55,0,43,35,90,90,90,90,90,90,90,90,90,90,0,0,55,0,0,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,18,19,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,0,0,0,0,45,0,16,16,16,16,16,16,16,16,16,16,55,0,0,0,0,0,0,16,16,16,16,16,16,28,28,28,28,28,28,28,28,28,28,55,0,0,0,0,0,0,28,28,28,28,28,28,0,0,0,16,16,16,16,16,16,37,0,0,76,76,76,76,76,76,76,76,76,76,0,0,0,0,28,28,28,28,28,28,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,18,19,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,40,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,6,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,31,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,34,0,0,0,0,34,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,4,4,4,4,4,4,76,76,76,76,76,76,76,76,76,76,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,34,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,34,0,0,0,0,0,34,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,10,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,1,41,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,25,26,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,18,19,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,34,34,34,34,34,34,34,34,34,34,0,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,86,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,23,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,0,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,0,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,0,83,83,83,83,83,83,83,83,0,22,24,63,63,63,63,63,63,63,63,63,63,0,0,0,0,0,0,0,63,63,63,63,63,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,63,63,63,63,63,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,55,0,0,0,0,0,75,75,75,75,75,75,75,75,75,75,63,63,63,63,63,63,63,63,63,63,0,0,0,0,0,0,0,63,63,63,63,63,63,0,0,0,0,0,66,0,0,0,0,0,0,0,0,65,0,0,0,15,0,0,0,0,0,0,0,63,63,63,63,63,63,0,0,0,17,0,66,0,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,40,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,41,6,30,30,30,30,30,30,30,30,30,30,30,30,30,30,31,11,20,20,20,21,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,74,0,68,68,68,68,68,68,68,68,88,88,89,89,89,89,89,89,89,89,89,89,0,36,0,0,0,0,0,0,72,0,0,36,77,0,0,0,0,71,78,0,0,0,0,0,0,0,0,0,0,0,0,0,0,36,0,0,0,0,0,0,72,0,0,36,77,0,0,0,0,70,78,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,18,19,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,74,0,68,68,68,68,68,68,68,68,88,88,75,75,75,75,75,75,75,75,75,75,0,36,0,0,0,0,0,0,72,0,0,36,77,0,0,0,0,71,78,0,38,0,0,76,76,76,76,76,76,76,76,76,76,36,0,0,0,0,0,0,72,0,0,36,77,77,0,0,0,70,78,78,38,0,0,0,0,0,83,0,0,0,0,0,0,0,0,83,83,83,83,83,83,83,83,83,83,77,0,0,0,0,0,78,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,0,0,0,0,83,0,83,83,83,83,85,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,83,0,0,0,0,0,0,0,0,83,83,83,83,83,83,83,83,83,83,0,0,0,0,0,0,0,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,0,0,0,0,83,35,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,81,83,83,83,83,83,83,83,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,83,0,0,0,0,0,0,0,0,83,83,83,83,83,83,83,83,83,83,0,0,0,0,0,0,0,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,0,0,0,0,83,35,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,83,0,0,0,0,0,0,0,0,83,83,83,83,83,83,83,83,83,83,0,0,0,0,0,0,0,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,0,0,0,0,83,35,83,83,83,83,83,83,83,83,83,83,83,82,83,83,83,83,83,83,83,83,83,83,83,83,83,83,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,83,0,0,0,0,0,0,0,0,83,83,83,83,83,83,83,83,83,83,0,0,0,0,0,0,0,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,0,0,0,0,83,35,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,74,0,87,87,87,87,87,87,87,87,87,87,0,0,0,0,0,0,0,0,0,0,0,36,0,0,0,0,0,0,61,0,0,0,0,0,0,0,74,60,88,88,88,88,88,88,88,88,88,88,0,0,0,0,0,36,0,0,0,0,0,36,61,0,0,0,0,0,0,0,0,59,35,89,89,89,89,89,89,89,89,89,89,90,90,90,90,90,90,90,90,90,90,36,36,77,0,0,0,0,0,78,0,0,0,77,0,0,0,0,0,78,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,77,0,0,0,0,0,78,0,0,0,77,0,0,0,0,0,78,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

alex_check :: Array Int Int
alex_check = listArray (0,3670) [-1,9,10,11,12,13,115,39,39,105,105,115,97,104,108,102,61,61,62,61,62,93,60,61,32,33,34,108,76,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,108,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,39,93,94,76,108,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,42,45,61,43,76,47,-1,48,49,50,51,52,53,54,55,56,57,61,92,-1,-1,61,-1,-1,65,66,67,68,69,70,-1,9,10,11,12,13,110,-1,-1,-1,114,45,116,117,48,49,50,51,52,53,54,55,56,57,32,-1,97,98,99,100,101,102,42,-1,-1,124,-1,47,195,48,49,50,51,52,53,54,55,56,57,-1,-1,61,-1,-1,-1,-1,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,42,-1,-1,-1,-1,47,-1,48,49,50,51,52,53,54,55,56,57,38,-1,-1,-1,-1,-1,-1,65,66,67,68,69,70,48,49,50,51,52,53,54,55,56,57,61,-1,-1,-1,-1,-1,-1,65,66,67,68,69,70,-1,-1,-1,97,98,99,100,101,102,45,-1,-1,48,49,50,51,52,53,54,55,56,57,-1,-1,-1,-1,97,98,99,100,101,102,-1,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,34,-1,-1,-1,-1,39,-1,-1,-1,-1,48,49,50,51,52,53,54,55,56,57,-1,-1,-1,-1,-1,-1,-1,65,66,67,68,69,70,48,49,50,51,52,53,54,55,56,57,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,92,97,98,99,100,101,102,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,110,-1,-1,-1,-1,-1,116,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,-1,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,42,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,194,195,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,0,1,2,3,4,5,6,7,8,9,-1,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,-1,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,-1,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,-1,184,185,186,187,188,189,190,191,-1,194,195,48,49,50,51,52,53,54,55,56,57,-1,-1,-1,-1,-1,-1,-1,65,66,67,68,69,70,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,97,98,99,100,101,102,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,10,42,-1,-1,-1,-1,-1,48,49,50,51,52,53,54,55,56,57,48,49,50,51,52,53,54,55,56,57,-1,-1,-1,-1,-1,-1,-1,65,66,67,68,69,70,-1,-1,-1,-1,-1,76,-1,-1,-1,-1,-1,-1,-1,-1,85,-1,-1,-1,99,-1,-1,-1,-1,-1,-1,-1,97,98,99,100,101,102,-1,-1,-1,116,-1,108,-1,-1,-1,-1,-1,-1,-1,-1,117,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,42,46,-1,48,49,50,51,52,53,54,55,56,57,48,49,50,51,52,53,54,55,56,57,-1,69,-1,-1,-1,-1,-1,-1,76,-1,-1,69,70,-1,-1,-1,-1,85,76,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,101,-1,-1,-1,-1,-1,-1,108,-1,-1,101,102,-1,-1,-1,-1,117,108,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,46,-1,48,49,50,51,52,53,54,55,56,57,48,49,50,51,52,53,54,55,56,57,-1,69,-1,-1,-1,-1,-1,-1,76,-1,-1,69,70,-1,-1,-1,-1,85,76,-1,88,-1,-1,48,49,50,51,52,53,54,55,56,57,101,-1,-1,-1,-1,-1,-1,108,-1,-1,101,102,70,-1,-1,-1,117,108,76,120,-1,-1,-1,-1,-1,39,-1,-1,-1,-1,-1,-1,-1,-1,48,49,50,51,52,53,54,55,56,57,102,-1,-1,-1,-1,-1,108,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,-1,-1,-1,-1,95,-1,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,39,-1,-1,-1,-1,-1,-1,-1,-1,48,49,50,51,52,53,54,55,56,57,-1,-1,-1,-1,-1,-1,-1,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,-1,-1,-1,-1,95,195,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,39,-1,-1,-1,-1,-1,-1,-1,-1,48,49,50,51,52,53,54,55,56,57,-1,-1,-1,-1,-1,-1,-1,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,-1,-1,-1,-1,95,195,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,39,-1,-1,-1,-1,-1,-1,-1,-1,48,49,50,51,52,53,54,55,56,57,-1,-1,-1,-1,-1,-1,-1,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,-1,-1,-1,-1,95,195,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,-1,-1,-1,-1,-1,-1,-1,-1,32,-1,-1,-1,-1,-1,-1,39,-1,-1,-1,-1,-1,-1,-1,-1,48,49,50,51,52,53,54,55,56,57,-1,-1,-1,-1,-1,-1,-1,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,-1,-1,-1,-1,95,195,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,46,-1,48,49,50,51,52,53,54,55,56,57,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,69,-1,-1,-1,-1,-1,-1,76,-1,-1,-1,-1,-1,-1,-1,46,85,48,49,50,51,52,53,54,55,56,57,-1,-1,-1,-1,-1,101,-1,-1,-1,-1,-1,69,108,-1,-1,-1,-1,-1,-1,-1,-1,117,195,48,49,50,51,52,53,54,55,56,57,48,49,50,51,52,53,54,55,56,57,101,69,70,-1,-1,-1,-1,-1,76,-1,-1,-1,70,-1,-1,-1,-1,-1,76,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,101,102,-1,-1,-1,-1,-1,108,-1,-1,-1,102,-1,-1,-1,-1,-1,108,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]

alex_deflt :: Array Int Int
alex_deflt = listArray (0,90) [-1,29,29,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,29,29,30,30,34,-1,34,5,5,-1,-1,29,42,42,-1,-1,-1,-1,-1,-1,-1,-1,43,43,43,43,-1,29,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]

alex_accept :: Array Int [AlexAcc (Posn -> S.Seq Char -> Token) user]
alex_accept = listArray (0::Int,90) [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[(AlexAccSkip)],[(AlexAccSkip)],[(AlexAccSkip)],[(AlexAccSkip)],[(AlexAcc (alex_action_3))],[(AlexAcc (alex_action_3))],[(AlexAcc (alex_action_3))],[(AlexAcc (alex_action_3))],[(AlexAcc (alex_action_3))],[(AlexAcc (alex_action_3))],[(AlexAcc (alex_action_3))],[(AlexAcc (alex_action_3))],[(AlexAcc (alex_action_3))],[(AlexAcc (alex_action_3))],[(AlexAcc (alex_action_3))],[(AlexAcc (alex_action_3))],[(AlexAcc (alex_action_4))],[(AlexAcc (alex_action_4))],[(AlexAcc (alex_action_5))],[(AlexAcc (alex_action_6))],[(AlexAcc (alex_action_7))],[(AlexAcc (alex_action_8))],[(AlexAcc (alex_action_8))],[(AlexAcc (alex_action_9))],[(AlexAcc (alex_action_10))],[(AlexAcc (alex_action_11))],[(AlexAcc (alex_action_11))],[(AlexAcc (alex_action_12))],[(AlexAcc (alex_action_12))],[(AlexAcc (alex_action_13))],[(AlexAcc (alex_action_14))],[(AlexAcc (alex_action_15))],[(AlexAcc (alex_action_15))],[(AlexAcc (alex_action_15))],[(AlexAcc (alex_action_16))],[(AlexAcc (alex_action_17))],[(AlexAcc (alex_action_18))],[(AlexAcc (alex_action_19))],[(AlexAcc (alex_action_20))],[(AlexAcc (alex_action_20))],[(AlexAcc (alex_action_20))],[(AlexAcc (alex_action_20))],[(AlexAcc (alex_action_20))],[(AlexAcc (alex_action_21))],[(AlexAcc (alex_action_22))],[(AlexAcc (alex_action_22))],[(AlexAcc (alex_action_23))],[(AlexAcc (alex_action_23))]]

tok f p s = f p s

--share :: S.Seq Char -> S.Seq Char
share = id

data Tok =
   TS !(S.Seq Char) !Int -- reserved words and symbols
 | TL !(S.Seq Char)      -- string literals
 | TI !(S.Seq Char)      -- integer literals
 | TV !(S.Seq Char)      -- identifiers
 | TD !(S.Seq Char)      -- double precision float literals
 | TC !(S.Seq Char)      -- character literals
 | T_Unsigned !(S.Seq Char)
 | T_Long !(S.Seq Char)
 | T_UnsignedLong !(S.Seq Char)
 | T_Hexadecimal !(S.Seq Char)
 | T_HexUnsigned !(S.Seq Char)
 | T_HexLong !(S.Seq Char)
 | T_HexUnsLong !(S.Seq Char)
 | T_Octal !(S.Seq Char)
 | T_OctalUnsigned !(S.Seq Char)
 | T_OctalLong !(S.Seq Char)
 | T_OctalUnsLong !(S.Seq Char)
 | T_JDouble !(S.Seq Char)
 | T_JFloat !(S.Seq Char)
 | T_JLongDouble !(S.Seq Char)
 | T_UnicodeChar !(S.Seq Char)
 | T_JChar !(S.Seq Char)
 deriving (Eq,Show,Ord)

data Token = 
   PT  Posn Tok
 | Err Posn
  deriving (Eq,Show,Ord)

data Posn = Pn !Int !Int !Int
        deriving (Eq,Show,Ord)

tokenPos (PT (Pn _ l _) _ :_) = "line " ++ show l
tokenPos (Err (Pn _ l _) :_) = "line " ++ show l
tokenPos _ = "end of file"

posLineCol (Pn _ l c) = (l,c)
mkPosToken t@(PT p _) = (posLineCol p, prToken t)

prToken t = case t of
  PT _ (TS s _) -> toList s
  PT _ (TI s) -> toList s
  PT _ (TV s) -> toList s
  PT _ (TD s) -> toList s
  PT _ (TC s) -> toList s
  PT _ (TL s) -> toList s
  PT _ (T_Unsigned s) -> toList s
  PT _ (T_Long s) -> toList s
  PT _ (T_UnsignedLong s) -> toList s
  PT _ (T_Hexadecimal s) -> toList s
  PT _ (T_HexUnsigned s) -> toList s
  PT _ (T_HexLong s) -> toList s
  PT _ (T_HexUnsLong s) -> toList s
  PT _ (T_Octal s) -> toList s
  PT _ (T_OctalUnsigned s) -> toList s
  PT _ (T_OctalLong s) -> toList s
  PT _ (T_OctalUnsLong s) -> toList s
  PT _ (T_JDouble s) -> toList s
  PT _ (T_JFloat s) -> toList s
  PT _ (T_JLongDouble s) -> toList s
  PT _ (T_UnicodeChar s) -> toList s
  PT _ (T_JChar s) -> toList s

--  _ -> S.fromList $ show t

data BTree = N | B (S.Seq Char) Tok BTree BTree deriving (Show)

eitherResIdent :: (S.Seq Char -> Tok) -> S.Seq Char -> Tok
eitherResIdent tv s = treeFind resWords
  where
  treeFind N = tv s
  treeFind (B a t left right) | s < a  = treeFind left
                              | s > a  = treeFind right
                              | s == a = t

resWords = b "int" (b "double" (b "catch" (b "break" (b "boolean" (b "abstract" N N) N) (b "case" (b "byte" N N) N)) (b "continue" (b "class" (b "char" N N) N) (b "do" (b "default" N N) N))) (b "float" (b "false" (b "extends" (b "else" N N) N) (b "finally" (b "final" N N) N)) (b "implements" (b "if" (b "for" N N) N) (b "instanceof" (b "import" N N) N)))) (b "static" (b "package" (b "native" (b "long" (b "interface" N N) N) (b "null" (b "new" N N) N)) (b "public" (b "protected" (b "private" N N) N) (b "short" (b "return" N N) N))) (b "throws" (b "synchronized" (b "switch" (b "super" N N) N) (b "throw" (b "this" N N) N)) (b "try" (b "true" (b "transient" N N) N) (b "while" (b "volatile" N N) N))))
   where b s = B (S.fromList s) (TS (S.fromList s) 1) -- TODO: The Integer?!

unescapeInitTail :: S.Seq Char -> S.Seq Char
unescapeInitTail = unesc . tail . toList where
  unesc s = case s of
    '\\':c:cs | elem c ['\"', '\\', '\''] -> S.singleton c <> unesc cs
    '\\':'n':cs  -> S.singleton '\n' <> unesc cs
    '\\':'t':cs  -> S.singleton '\t' <> unesc cs
    '"':[]    -> mempty
    c:cs      -> S.singleton c <> unesc cs
    _         -> mempty

-------------------------------------------------------------------
-- Alex wrapper code.
-- A divide and conquer wrapper.
-------------------------------------------------------------------
-- Generic template
type State = Int
type Transition v = State -> (Tokens v) -- Transition from in state to Tokens
-- Wrapper template?
data Tokens v = NoTokens
              | InvalidTokens !(S.Seq Char)
              | Tokens { currentSeq  :: !(FingerTree v IntToken)
                        , lastToken  :: !(Suffix v)
                        , outState   :: !State}
-- The suffix is the the sequence of as long as possible accepting tokens.
-- It can itself contain a suffix for the last token.
                 -- deriving Show
--This is either a Sequence of tokens or one token if the it hits an accepting state with later characters
-- Generic template
data Suffix v = Str !(S.Seq Char)
              | One !IntToken
              | Multi !(Tokens v)
                 -- deriving Show
type Size     = Sum Int
--Wrapper
type LexTree v = FingerTree (Table State (Tokens v),Size) Char
data IntToken  = Token { lexeme   :: !(S.Seq Char)
--                      , prev     :: Char
                      , token_id :: Accepts}
--Wrapper template
type Accepts   = [AlexAcc (Posn -> S.Seq Char -> Token) ()]

tabulate :: (State,State) -> (State -> b) -> Table State b
access :: Table State b -> (State -> b)

--debug stuff
-- instance Show b => Show (Table Int b) where
--   show f = unlines $ ["\n\n\n\n" ++ show i ++ " -> " ++ show (access f i) | i <- [0,29]]

type Table a b = Array State b
tabulate range f = listArray range [f i | i <- [fst range..snd range]]
access a x = a ! x
--}

-- debug stuffs
instance Show IntToken where
  show token = case map showAcc (token_id token) of
      [] -> "No Token:" ++ show (lexeme token) ++ "\n"
      toks -> unlines toks
    where showAcc acc = case acc of 
            AlexAcc f -> show $ f (Pn 0 0 0) (lexeme token)
            AlexAccSkip -> "Skip:" ++ show (lexeme token)

-- Generic template
instance (Measured v IntToken) => Monoid (Table State (Tokens v)) where
  mempty = tabulate stateRange (\_ -> emptyTokens)
  f `mappend` g = tabulate stateRange $ combineTokens (access f) (access g)

-- Wrapper template
-- The base case for when one character is lexed.
instance (Measured v IntToken) => Measured (Table State (Tokens v),Size) Char where
  measure c =
    let bytes = encode c
        sing = singleton c
        cSeq = S.singleton c
        baseCase in_state | in_state == -1 = InvalidTokens cSeq
                          | otherwise = case foldl automata in_state bytes of
          -1 -> InvalidTokens cSeq
          os -> case alex_accept ! os of
            []  -> Tokens empty (Str cSeq) os
            acc -> Tokens empty (One (createToken cSeq acc)) os
    in (tabulate stateRange $ baseCase, Sum 1)

-- And this would be where A0A1 \elem P should be computed
-- Should this even be Category? Well, I think so.
-- instance Monoid Category where
--     mempty          = undefined
--     c1 `mappend` c2 = case combine True c1 c2 of
--         [] :/: []    -> error "NOES" -- ehh?
--         left :/: []  -> fst left  -- error, or what?
--         [] :/: right -> fst right

createToken :: S.Seq Char -> Accepts -> IntToken
createToken lex acc = Token lex acc

createTokens :: Measured v IntToken => FingerTree v IntToken -> Suffix v -> State -> Tokens v
createTokens seq suf state = if null seq
                             then NoTokens
                             else Tokens seq suf state

-- Wrapper template
invalidTokens :: S.Seq Char -> Tokens v
invalidTokens s = InvalidTokens s

-- Wrapper template
emptyTokens :: Tokens v
emptyTokens = NoTokens

--------- Combination functions, the conquer step

-- Generic template
-- Combines two transition maps
combineTokens :: Measured v IntToken => Transition v -> Transition v -> Transition v
combineTokens trans1 trans2 in_state | isInvalid toks1 = toks1
                                     | isEmpty toks1   = trans2 in_state
                                     | otherwise = combineWithRHS toks1 trans2
  where toks1 = trans1 in_state

-- Generic template
-- Tries to merge tokens first, if it can't it either appends the token or calls
-- itself if the suffix contains Tokens instaed of a single token.
combineWithRHS :: Measured v IntToken => Tokens v -> Transition v -> Tokens v
combineWithRHS toks1 trans2 | isEmpty toks2 = toks1
                            | isValid toks2 =
    let toks2' = mergeTokens (lastToken toks1) toks2 trans2
    in appendTokens seq1 toks2'                           
                            | otherwise     = case lastToken toks1 of
    Multi suffToks ->
      let toks2' = combineWithRHS suffToks trans2 -- try to merge suffix
      in appendTokens seq1 toks2'
    One tok -> appendTokens (seq1 |> tok) (trans2 startState)
    Str s -> invalidTokens s
  where toks2 = trans2 $ outState toks1
        seq1 = currentSeq toks1

-- Generic template
-- Creates one token from the last token of the first sequence and and the first
-- token of the second sequence and inserts it between the init of the first
-- sequence and the tail of the second sequence
mergeTokens :: Measured v IntToken => Suffix v -> Tokens v -> Transition v -> Tokens v
mergeTokens suff1 toks2 trans2 = case viewl (currentSeq toks2) of
  token2 :< seq2' -> let newToken = mergeToken suff1 token2
                     in toks2 {currentSeq = newToken <| seq2'}
  EmptyL -> case alex_accept ! out_state of
    [] -> toks2 {lastToken = mergeSuff suff1 (lastToken toks2) trans2}
    acc -> let lex = suffToStr suff1 <> suffToStr (lastToken toks2)
           in toks2 {lastToken = One $ createToken lex acc}
  where out_state = outState toks2

-- Generic template
-- Creates on token from a suffix and a token
mergeToken :: Suffix v -> IntToken -> IntToken
mergeToken suff1 token2 = token2 {lexeme = suffToStr suff1 <> lexeme token2}

-- Generic template
-- Creates the apropiet new suffix from two suffixes
mergeSuff :: Measured v IntToken => Suffix v -> Suffix v -> Transition v -> Suffix v
mergeSuff (Multi toks1) suff2 trans2 = Multi $ -- O(n^2)
  let newToks = combineWithRHS toks1 trans2
  in if isValid $ newToks
     then newToks
     else toks1 {lastToken = mergeSuff (lastToken toks1) suff2 trans2}
mergeSuff (Str s1) suff2 _ = Str $ s1 <> suffToStr suff2
mergeSuff (One token1) (Str s) trans2 =
  let toks2 = trans2 startState
  in if isValid toks2
     then Multi $ toks2 {currentSeq = token1 <| currentSeq toks2}
     else Multi $ createTokens (singleton token1) (Str s) (-1)
mergeSuff suff1 (One token2) _ = One $ mergeToken suff1 token2 -- O(n)
mergeSuff suff1 (Multi toks2) trans2 = Multi $ mergeTokens suff1 toks2 trans2 -- O(n^2)

-- Generic template
-- Prepends a sequence of tokens on the sequence in Tokens
appendTokens :: Measured v IntToken => FingerTree v IntToken -> Tokens v -> Tokens v
appendTokens seq1 toks2 | isValid toks2 = toks2 {currentSeq = seq1 <> currentSeq toks2}
                        | otherwise = toks2

---------- Constructors

-- Generic template
makeTree :: Measured v IntToken => String -> LexTree v
makeTree  = fromList

{-
-- Wrapper template
measureToTokens :: Measured v IntToken => (Table State (Tokens v),Size) -> FingerTree v Token
measureToTokens m = case access (fst $ m) startState of
  InvalidTokens s -> error $ "Unacceptable token: " ++ toList s
  NoTokens -> empty
  Tokens seq suff out_state -> 
    snd $ foldlWithIndex showToken (Pn 0 1 1,empty) $ intToks seq suff
  where 
    -- Reconstructing the one from Data.Sequence
    foldlWithIndex :: (b -> Int -> a -> b) -> b -> FingerTree v a -> b
    foldlWithIndex f z xs = foldl (\ g x i -> i `seq` f (g (i - 1)) i x) (const z) xs (length xs - 1)

    showToken (pos,toks) _ (Token lex accs) =
      let pos' = foldl alexMove pos lex
      in case accs of
        [] -> (pos',toks)
        AlexAcc f:_   -> (pos',toks |> f pos lex)
        AlexAccSkip:_ -> (pos',toks)

    intToks :: Measured v IntToken => FingerTree v IntToken -> Suffix v -> FingerTree v IntToken
    intToks seq (Str str) = error $ "Unacceptable token: " ++ toList str
    intToks seq (One token) = seq |> token
    intToks seq (Multi (Tokens seq' suff' _)) = intToks (seq <> seq') suff'

-- Generic template
treeToTokens :: Measured v IntToken => LexTree v -> FingerTree v IntToken
treeToTokens = measureToTokens . measure
-}

------------- Util funs

-- Wrapper template
isValid :: Tokens v -> Bool
isValid (Tokens _ _ _) = True
isValid _ = False

-- Wrapper template
isEmpty :: Tokens v -> Bool
isEmpty NoTokens = True
isEmpty _        = False

-- Wrapper template
isInvalid :: Tokens v -> Bool
isInvalid (InvalidTokens _) = True
isInvalid _ = False

-- Generic template
suffToStr :: Suffix v -> S.Seq Char
suffToStr (Str s) = s
suffToStr (One token) = lexeme token
suffToStr (Multi toks) =
  concatLexemes (currentSeq toks) <> suffToStr (lastToken toks)

isAccepting :: Tokens v -> Bool
isAccepting (Tokens _ suff _) = case suff of
  Str _ -> False
  One _ -> True
  Multi toks -> isAccepting toks
isAccepting NoTokens = True
isAccepting _ = False

-- Genereic template
concatLexemes :: FingerTree v IntToken -> S.Seq Char
concatLexemes = foldr ((<>) . lexeme) mempty

insertAtIndex :: Measured v IntToken => String -> Int -> LexTree v -> LexTree v
insertAtIndex str i tree = 
  if i < 0
  then error "index must be >= 0"
  else l <> (makeTree str) <> r
     where (l,r) = splitTreeAt i tree

splitTreeAt :: Measured v IntToken => Int -> LexTree v -> (LexTree v,LexTree v)
splitTreeAt i tree = split (\(_,s) -> getSum s>i) tree

size :: Measured v IntToken => LexTree v -> Int
size tree = getSum . snd $ measure tree

suffSize :: Suffix v -> Int
suffSize (Multi toks) = toksSize toks
suffSize (Str s) = S.length s
suffSize (One (Token lex _)) = S.length lex

toksSize :: Tokens v -> Int
toksSize (Tokens seq suff _) = suffSize suff + foldl bla 0 seq
  where bla _ (Token lex _) = S.length lex
toksSize _ = 0

-- wrapper template
alexMove :: Posn -> Char -> Posn
alexMove (Pn a l c) '\t' = Pn (a+1)  l     (((c+7) `div` 8)*8+1)
alexMove (Pn a l c) '\n' = Pn (a+1) (l+1)   1
alexMove (Pn a l c) _    = Pn (a+1)  l     (c+1)

-- Starting state
startState = 0
-- A tuple that says how many states there are
stateRange = let (start,end) = bounds alex_accept
             in (start-1,end)

-- Generic
-- Takes an in state and a byte and returns the corresponding out state using the DFA
automata :: Int -> Word8 -> Int
automata (-1) _ = -1
automata s c = let base   = alex_base ! s
                   ord_c  = fromEnum c
                   offset = base + ord_c
                   check  =  alex_check ! offset
               in if (offset >= (0)) && (check == ord_c)
                  then alex_table ! offset
                  else alex_deflt ! s

-- wrapper (Not byteString but others)
-- Converts an UTF8 character to a list of bytes
encode :: Char -> [Word8]
encode  = map fromIntegral . go . fromEnum
 where
  go oc
   | oc <= 0x7f       = [oc]
   | oc <= 0x7ff      = [ 0xc0 + (oc `shiftR` 6)
                        , 0x80 + oc .&. 0x3f
                        ]
   | oc <= 0xffff     = [ 0xe0 + (oc `shiftR` 12)
                        , 0x80 + ((oc `shiftR` 6) .&. 0x3f)
                        , 0x80 + oc .&. 0x3f
                        ]
   | otherwise        = [ 0xf0 + (oc `shiftR` 18)
                        , 0x80 + ((oc `shiftR` 12) .&. 0x3f)
                        , 0x80 + ((oc `shiftR` 6) .&. 0x3f)
                        , 0x80 + oc .&. 0x3f
                        ]

alex_action_3 =  tok (\p s -> PT p (TS (share s) 1)) 
alex_action_4 =  tok (\p s -> PT p (eitherResIdent (T_Unsigned . share) s)) 
alex_action_5 =  tok (\p s -> PT p (eitherResIdent (T_Long . share) s)) 
alex_action_6 =  tok (\p s -> PT p (eitherResIdent (T_UnsignedLong . share) s)) 
alex_action_7 =  tok (\p s -> PT p (eitherResIdent (T_Hexadecimal . share) s)) 
alex_action_8 =  tok (\p s -> PT p (eitherResIdent (T_HexUnsigned . share) s)) 
alex_action_9 =  tok (\p s -> PT p (eitherResIdent (T_HexLong . share) s)) 
alex_action_10 =  tok (\p s -> PT p (eitherResIdent (T_HexUnsLong . share) s)) 
alex_action_11 =  tok (\p s -> PT p (eitherResIdent (T_Octal . share) s)) 
alex_action_12 =  tok (\p s -> PT p (eitherResIdent (T_OctalUnsigned . share) s)) 
alex_action_13 =  tok (\p s -> PT p (eitherResIdent (T_OctalLong . share) s)) 
alex_action_14 =  tok (\p s -> PT p (eitherResIdent (T_OctalUnsLong . share) s)) 
alex_action_15 =  tok (\p s -> PT p (eitherResIdent (T_JDouble . share) s)) 
alex_action_16 =  tok (\p s -> PT p (eitherResIdent (T_JFloat . share) s)) 
alex_action_17 =  tok (\p s -> PT p (eitherResIdent (T_JLongDouble . share) s)) 
alex_action_18 =  tok (\p s -> PT p (eitherResIdent (T_UnicodeChar . share) s)) 
alex_action_19 =  tok (\p s -> PT p (eitherResIdent (T_JChar . share) s)) 
alex_action_20 =  tok (\p s -> PT p (eitherResIdent (TV . share) s)) 
alex_action_21 =  tok (\p s -> PT p (TL $ share $ unescapeInitTail s)) 
alex_action_22 =  tok (\p s -> PT p (TI $ share s))    
alex_action_23 =  tok (\p s -> PT p (TD $ share s)) 
-- -----------------------------------------------------------------------------
-- ALEX TEMPLATE
--
-- This code is in the PUBLIC DOMAIN; you may copy it freely and use
-- it for any purpose whatsoever.

-- -----------------------------------------------------------------------------
-- INTERNALS and main scanner engine
{-
alexIndexInt16OffAddr arr off = arr ! off


alexIndexInt32OffAddr arr off = arr ! off


quickIndex arr i = arr ! i
-}

-- -----------------------------------------------------------------------------
-- Main lexing routines
{-
data AlexReturn a
  = AlexEOF
  | AlexError  !AlexInput
  | AlexSkip   !AlexInput !Int
  | AlexToken  !AlexInput !Int a

-- alexScan :: AlexInput -> StartCode -> AlexReturn a
alexScan input (sc)
  = alexScanUser undefined input (sc)

alexScanUser user input (sc)
  = case alex_scan_tkn user input (0) input sc AlexNone of
	(AlexNone, input') ->
		case alexGetByte input of
			Nothing -> 



				   AlexEOF
			Just _ ->



				   AlexError input'

	(AlexLastSkip input'' len, _) ->



		AlexSkip input'' len

	(AlexLastAcc k input''' len, _) ->



		AlexToken input''' len k


-- Push the input through the DFA, remembering the most recent accepting
-- state it encountered.

alex_scan_tkn user orig_input len input s last_acc =
  input `seq` -- strict in the input
  let 
	new_acc = (check_accs (alex_accept `quickIndex` (s)))
  in
  new_acc `seq`
  case alexGetByte input of
     Nothing -> (new_acc, input)
     Just (c, new_input) -> 



	let
		(base) = alexIndexInt32OffAddr alex_base s
		((ord_c)) = fromIntegral c
		(offset) = (base + ord_c)
		(check)  = alexIndexInt16OffAddr alex_check offset
		
		(new_s) = if (offset >= (0)) && (check == ord_c)
			  then alexIndexInt16OffAddr alex_table offset
			  else alexIndexInt16OffAddr alex_deflt s
	in
	case new_s of 
	    (-1) -> (new_acc, input)
		-- on an error, we want to keep the input *before* the
		-- character that failed, not after.
    	    _ -> alex_scan_tkn user orig_input (if c < 0x80 || c >= 0xC0 then (len + (1)) else len)
                                                -- note that the length is increased ONLY if this is the 1st byte in a char encoding)
			new_input new_s new_acc

  where
	check_accs [] = last_acc
	check_accs (AlexAcc a : _) = AlexLastAcc a input (len)
	check_accs (AlexAccSkip : _)  = AlexLastSkip  input (len)
	check_accs (AlexAccPred a predx : rest)
	   | predx user orig_input (len) input
	   = AlexLastAcc a input (len)
	check_accs (AlexAccSkipPred predx : rest)
	   | predx user orig_input (len) input
	   = AlexLastSkip input (len)
	check_accs (_ : rest) = check_accs rest

data AlexLastAcc a
  = AlexNone
  | AlexLastAcc a !AlexInput !Int
  | AlexLastSkip  !AlexInput !Int

instance Functor AlexLastAcc where
    fmap f AlexNone = AlexNone
    fmap f (AlexLastAcc x y z) = AlexLastAcc (f x) y z
    fmap f (AlexLastSkip x y) = AlexLastSkip x y
-}
data AlexAcc a user
  = AlexAcc a
  | AlexAccSkip
--  | AlexAccPred a (AlexAccPred user)
--  | AlexAccSkipPred (AlexAccPred user)
{-
type AlexAccPred user = user -> AlexInput -> Int -> AlexInput -> Bool

-- -----------------------------------------------------------------------------
-- Predicates on a rule

alexAndPred p1 p2 user in1 len in2
  = p1 user in1 len in2 && p2 user in1 len in2

--alexPrevCharIsPred :: Char -> AlexAccPred _ 
alexPrevCharIs c _ input _ _ = c == alexInputPrevChar input

alexPrevCharMatches f _ input _ _ = f (alexInputPrevChar input)

--alexPrevCharIsOneOfPred :: Array Char Bool -> AlexAccPred _ 
alexPrevCharIsOneOf arr _ input _ _ = arr ! alexInputPrevChar input

--alexRightContext :: Int -> AlexAccPred _
alexRightContext (sc) user _ _ input = 
     case alex_scan_tkn user input (0) input sc AlexNone of
	  (AlexNone, _) -> False
	  _ -> True
	-- TODO: there's no need to find the longest
	-- match when checking the right context, just
	-- the first match will do.

-- used by wrappers
iUnbox (i) = i
-}
