Log of progress, meetings, but also random thoughts.
====================================================

Notes before supervision 2014-03-03
===================================
* Is it reasonable to have the possibility to use LexGen code in BNFC without
  having to use an incremental parser? It would be a nice bonus, in that case.

Notes 2014-02-25
================
* IntToken -> Token thing, it's really weird to wrap around. The composition of
  monoids makes no sense to me. An IntToken has Accepts as part of its record,
  which is a list of [AlexAcc (Posn -> S.Seq Char -> Token)], so to create a
  token from an IntToken we need both positions and a char sequence. How can
  that be combined with a position and adding a char sequence as well?
  Investigation needed!

Notes after supervision 2014-02-24
==================================
* mkMat does not need Shapes as arguments, since they are already baked into the
  Mat type.
* It would be reasonable to have a chapter about dependently typed Haskell in
  the final report.

Notes before supervision 2014-02-24
===================================
* How to implement the applicative pure for Mat x y. Lifting a value to a matrix
  of arbitrary size seems...infeasible.
* Is there a simple way to find the shape of a Mat without having it passed as
  an argument in the first place?
* What is the mul function in RingP really supposed to do?

Notes after supervision 2014-02-18
==================================
* chopFirstRow has to recurse on c and d in the base case. Creating four rows
  will enable creation of a quad of everything except a b. The same goes for
  chopLastCol etc.
* For general type safety, the data type containing chop dependent data should
  be separated into two types, one for rows and one for cols.
* The change in alex template generation should be done in BNFC. Preferrably the
  changes are connected to the --cnf option. This should probably be easy, so
  best to do it as soon as possible.
* The test program in BNFC will probably have to be changed slightly
* Send the planning report to JPB before next supervision.

Notes after supervision 2014-02-11
==================================
* The Pair (se below) has to do with the balancing (and the oracle stuff)
    - NOTE to self: this is not at all obvious. Look it up further.
* The issue of Posn can be solved by combining several monoids, so it should not
  be a problem. This is something that is also implemented in Ropes in Yi. 
* TODO: implement the recursive cases for chopLast/chopFirst
    - NOTE to self: Draw matrices by hand, it makes stuff much easier.
* For more dependently typed Haskell, "hasochism" from Haskell symposium 2013.

2014-02-11
==========
* It is frustrating that my progress is insanely slow
* Exactly what is the plan?
    - Merge LexGen and ParParse
        - LexGen measure should be Token instead of IntToken
        - How to add Posn to each token while still lazy/incremental?
        - There are lots of other stuff to change in LexGen to conform it to
          BNFC generated code for future use.
    - Merge-function in Quad.hs
        - What is the point of having Pair (Mat x y a) ?

2014-02-03
==========

merge function

...Quad.hs:
 mergein :: RingP a => Bool -> SomeTri a -> Pair a -> SomeTri a -> SomeTri a

 
Further Notes 2014-01-31
========================
* It is disturbing although convenient to write this code for a specific
  language. Care must be taken to make sure it is easy to generalize.

* Eh...in what way can the CYK tables be used in the matrix stuff? Needs to be
  further examined as of now.

* Remember to print "important" MSc thesis forms on monday. Also: planning
  report should be done some time..

Notes 2014-01-31
================
* Parametrization of LexGen results were successful, it forced some new
  constraints to many functions, but looks good otherwise.
  NOTE: This was not obvious to me, but neccessary in order to make the results
        work incrementally.

* Now we more or less want to use the tables from bnfc --cnf to see what parts
  we can use to see if we have A0A1 \elem P.

* We want sigma to be measure and A0A1 \elem P as mappend.

Supervision 2014-01-27
======================
* We don't want to do measure . measure, but rather have LexGen store its result
  as FingerTree instead of Seq IntToken, so that we can measure it with our own
  measure function (matrix stuff)

* BNFC rules are generated by BNFC/Backend/Haskell/ToCNF.hs and
                                          /Haskell.hs

* For the planning report, these logs with sugar can be used, more or less.

Supervision 2014-01-14
======================

* Discussions about setup of repo, supervision, expectations etc
    - Supervision mondays
    - Approx 2 months work, 2 months report writing
    - Midway report around easter

* Guidelines for the report
    - Should be readable by other MSc students
    - Should contain everything interesting/non-obvious

* Things to think about in the actual project
    - How to handle wrong input
        - And how to know what part is bad?
        - Overlaps in matrix - decision needed!
    - How to combine lexer and parser neatly w/ Monoid & Measure
        - This is the first large challenge!
        - Once done - test it as simple as possible.

* Where to find code?
    - BNFC
    - LexGen
    - Yi

Project start 2014-01-13 - 14
========================
* Reading paper by Valiant
* Reading paper by Claessen & Bernardy
* Walkthrough of LexGen by Kristofer

